{
    "collab_server" : "",
    "contents" : "##' @title Clustering by Hierachical Nearest Neighbor Descent\n##'\n##' @description Clustering by Hierachical Nearest Neighbor Descent (equivalent to: Clustering by Hierachical Nearest Neighbor Ascent)\n##'\n##' @param x dataset (a matrix with rows denoting samples and columns denoting features\n##' @param K number of nearest neighbors (emperical value: the nearest integer to log2(N), where N is the size of the dataset)\n##' @param h a threshold for deciding when to start the ND layer (usually h = k)\n##' @param LogPlot whether to show the decision graph in the log scale\n##' @param disName distance measurement ('euclidean','cosine', and'l2' are supported)\n##'\n##' @return I:    parent node vector;\n##' @return W:    edge weigth vector;\n##' @return Label:    cluster label vector;\n##' @return Totoltime_DG:     time spent on the interactive operation on the Decision Graph (which is user-dependent and is thus suggested to be subtracted from the total runtime);\n##'\n##'\n##' @examples\n##' data('cytof.benchmark.h1')\n##' x = cytof.benchmark.h1$x\n##' K = ceiling(log2(nrow(x)))\n##' result <- HNND_C(x = x,K = K,h = K,disName = \"euclidean\",LogPlot = '')\n##'\n##' @author Teng Qiu\nHNND_C = function(\n  x,\n  K = 20,\n  h = 20,\n  disName = \"euclidean\",\n  LogPlot = ''){\n\n  if (!any(disName == c('euclidean','cosine','l2'))) stop('distance metric not supported')\n\n  if (ncol(x)<=10){\n    knn_method = 'kd_tree'\n  } else {\n    knn_method = \"hnsw\"  # note: all the test datasets in HNND-PR have higher dimensions than 10\n  }\n  # HNND ---------------------------------------------------------------\n\n  N = nrow(x)\n  Dim = ncol(x)\n  print(paste0('fast knn (',knn_method,')...'))\n\n  switch(knn_method,\n         \"kd_tree\" = {\n           Kd_tree_construction <- WKNNF(x)\n           knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n           names(knn)[1] <- \"nn.index\"\n           names(knn)[2] <- \"nn.dist\"\n           knn$nn.index = knn$nn.index[,-1]\n           knn$nn.dist = knn$nn.dist[,-1]\n         },\n         \"hnsw\" = {\n           ann = RcppHNSW::hnsw_build(x,disName)\n           knn = queryKnnHNSW(ann,x,K+1,disName)\n         }\n  )\n\n  print(\"density estimation...\")\n  Density_initial = simlified_knn_density_estimation_v1(knn)\n\n  print(\"1st round NND:\")\n  nnd = NND(Density_initial,knn)\n\n  I=nnd$I\n  W=nnd$W\n\n  root_id = nnd$roots\n  nnd_root_initial = nnd$roots\n  layer = 1\n\n  print(\"other round NND:\")\n\n  while(1){\n\n    if (length(root_id) <= h) break\n\n    switch(knn_method,\n           \"kd_tree\" = {\n             Kd_tree_construction <- nabor::WKNNF(x[root_id,])\n             knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n             names(knn)[1] <- \"nn.index\"\n             names(knn)[2] <- \"nn.dist\"\n             knn$nn.index = knn$nn.index[,-1]\n             knn$nn.dist = knn$nn.dist[,-1]\n           },\n           \"hnsw\" = {\n             ann = RcppHNSW::hnsw_build(x[root_id,],disName)\n             knn = RcppHNSW::hnsw_search(x[root_id,],ann,K+1)\n\n             names(knn)[1] <- \"nn.index\"\n             names(knn)[2] <- \"nn.dist\"\n             knn$nn.index = knn$nn.index[,-1]\n             knn$nn.dist = knn$nn.dist[,-1]\n           }\n    )\n\n    if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n      # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n      nnd = NND(Density_initial[root_id],knn)\n      I[root_id]=root_id[nnd$I]\n      W[root_id]=nnd$W\n      root_id = root_id[nnd$roots]\n    }else{\n      I[root_id]=min(root_id)\n      W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n      root_id = min(root_id)\n    }\n    layer = layer + 1\n  }\n\n  Hnnd_root_id = root_id\n\n  if (length(root_id) > 1){\n    nd=ND(Density_initial[root_id],x[root_id,],disName)\n    I[root_id]=root_id[nd$I]\n    W[root_id]=nd$W\n    Hnnd_root_id =which(I==c(1:N))\n  }\n\n  # Cut edges ---------------------------------------------------------------\n\n  time_DG<-system.time({\n    peaks = DecisionGraph(W,I,Density_initial,Log = LogPlot)\n  })[3]\n\n  # search root -----\n\n  I[peaks]=peaks\n  print(\"dynamic update the parent node:\")\n  I_old=I\n  I=I_old[I_old]\n  while(sum(as.numeric(I-I_old))){\n    I_old=I\n    I=I_old[I_old]\n  }\n  Label = I\n\n  return(list(I = I, W = W, Label=Label,time_DG = time_DG))\n}\n\n",
    "created" : 1611140599009.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "897003747",
    "id" : "35BED6FA",
    "lastKnownWriteTime" : 1611147620,
    "last_content_update" : 1611147620118,
    "path" : "F:/Download_code/TPE/tpe/R/HnndPRdata/Clustering-by-HNND-PR-Github/R/HNND_C.R",
    "project_path" : "R/HNND_C.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}