{
    "collab_server" : "",
    "contents" : "fast_HNND_based_on_unit_free_index_v1_function = function(\n  x,K = NaN,alpha = 0.95,\n  InTree_construction_method_id =NaN,\n  intercluster_edges_method_id = 'DG',\n  disName = \"euclidean\",\n  knn_method = 'kd_tree',\n  densityMethod = 'knn_based_only',\n  Threshold_RootNum = 1,\n  NumT = 50,\n  ClustN = NaN,\n  Linkage = \"ward\",\n  h = 50,\n  thresh_k = 5,\n  reuse_tree_contruction = \"off\",\n  knn_type = \"out_knn\",\n  data_name = NaN){\n  ## InTree_construction_method_id:  \"Hnnd\",\"Dnnd\",\"NA\",\"NNA\",\"NA+\",\"NA++\",NA+++,NA++++\n  ## intercluster_edges_method_id: different methods are available\n  if (!any(disName == c('euclidean','cosine','l2'))) stop('distance metric not supported')\n  K_initial = K\n  Totoltime = vector()\n  # construct the in-tree\n  R_num_each_layer = vector()\n  listRootIndEachLayer = list()\n  switch(InTree_construction_method_id,\n         # Hnnd --------------------------------------------------------------------\n         \"Hnnd\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           # nnd=NND_k(x,K,alpha)\n           nnd=NND_k_V2(x,K,alpha,knn_method,densityMethod)\n           \n           \n           I=nnd$I\n           W=nnd$W\n           knn_initial = nnd$knn\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = root_id\n           Density_initial = nnd$P_Amp\n           \n           H_P_Amp=nnd$P_Amp[root_id]\n           nd=ND_less_space_consumption(H_P_Amp,x[root_id,],disName)\n           \n           \n           I[root_id]=root_id[nd$I]\n           W[root_id]=nd$W\n           Hnnd_root_id =which(I==c(1:N))\n         },\n         # Hnnd_ML ---------------------------------------------------------------\n         \"Hnnd_ML\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      message(\"directly Load knn graph built by hnsw...\")\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      \n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                    } else{\n                      ann = hnsw_build(x,disName)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                       \n                       \n                      # if (disName == 'euclidean'){\n                        # filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')   \n                        # ann$save(filename)\n                      # }\n                    }\n                    \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){ \n                      if (disName == \"euclidean\"){\n                        filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                        tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      } else {\n                        stop('distance metric not supported')\n                      }\n                      \n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    if (disName == \"euclidean\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                    } else {\n                      stop('distance metric not supported')\n                    }\n                    tree.index$save(filename)\n                  }\n           )\n           \n           knn_initial = knn\n           print(\"density estimation...\")\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           } else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           } else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           print(\"1st round NND:\")\n           \n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           \n           I=nnd$I\n           W=nnd$W\n           \n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           \n           print(\"other round NND:\")\n           \n           while(1){\n             R_num_each_layer[layer] = print(length(root_id))\n             if (length(root_id) <= h) break \n             \n             listRootIndEachLayer [[layer]] = root_id\n             \n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      Kd_tree_construction <- WKNNF(x[root_id,])\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"hnsw\" = {\n                      ann = hnsw_build(x[root_id,],disName)\n                      knn = hnsw_search(x[root_id,],ann,K+1)\n                      \n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"PR_tree\" = {\n                      tree.index = ConstructKnnRandomProjection(x[root_id,],NumT,disName)\n                      knn = queryKnnRandomProjection(tree.index,1:length(root_id),K)\n                      \n                    }\n             )\n             \n             \n             \n             if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               nnd = NND_no_density_estimation_V1_memory_saving(Density_initial[root_id],knn)\n               I[root_id]=root_id[nnd$I]\n               \n               W[root_id]=nnd$W\n               \n               root_id = root_id[nnd$W_Max_idx]\n             }else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               \n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           \n           \n           \n           R_num_each_layer[layer] =length(root_id)\n           listRootIndEachLayer [[layer]] = root_id\n           \n           Hnnd_root_id = root_id\n           \n           if (length(root_id) > 1){\n             nd=ND_less_space_consumption(Density_initial[root_id],x[root_id,],disName)\n             I[root_id]=root_id[nd$I]\n             W[root_id]=nd$W\n             Hnnd_root_id =which(I==c(1:N))\n           }\n           \n         }, \n         # combine hnnd with Densitycut ---------------------------------------------------------------\n         \"Combine_HNND_Densitycut\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           print(paste(knn_method,\" knn\"))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    \n                    ann = hnsw_build(x,disName)\n                    knn = hnsw_search(x,ann,K+1)\n                    \n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"PR_tree\" = {\n                    tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    \n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           print(\"density estimation...\")\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           } else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           print(\"1st round NND: \")\n           \n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           \n           I=nnd$I\n           W=nnd$W\n           \n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           \n           print(\"other round NND:\")\n           \n           while(1){\n             R_num_each_layer[layer] = print(length(root_id))\n             if (length(root_id) <= h) break\n             \n             \n             listRootIndEachLayer [[layer]] = root_id\n             \n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      Kd_tree_construction <- WKNNF(x[root_id,])\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"hnsw\" = {\n                      ann = hnsw_build(x[root_id,],disName)\n                      knn = hnsw_search(x[root_id,],ann,K+1)\n                      \n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"PR_tree\" = {\n                      tree.index = ConstructKnnRandomProjection(x[root_id,],NumT,disName)\n                      knn = queryKnnRandomProjection(tree.index,1:length(root_id),K)\n                      \n                    }\n             )\n             \n             \n             \n             if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               nnd = NND_no_density_estimation_V1_memory_saving(Density_initial[root_id],knn)\n               I[root_id]=root_id[nnd$I]\n               \n               W[root_id]=nnd$W\n               \n               root_id = root_id[nnd$W_Max_idx]\n             }else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               \n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           \n           \n           \n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           \n           Hnnd_root_id = root_id\n           \n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x[root_id,])\n                    knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    ann = hnsw_build(x[root_id,],disName)\n                    knn = hnsw_search(x[root_id,],ann,K+1)\n                    \n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"PR_tree\" = {\n                    tree.index = ConstructKnnRandomProjection(x[root_id,],NumT,disName)\n                    knn = queryKnnRandomProjection(tree.index,1:length(root_id),K)\n                    \n                  }\n           )\n           \n           ## DensityCut-based post-processing\n           DC=densitycut::DensityCut(knn.index = knn$nn.index, knn.dist = knn$nn.dist)\n           \n           \n           \n           I2= vector(length = length(root_id))\n           uni = as.numeric(names(table(DC$cluster)))\n           for (uni_id in 1:length(uni)){\n             I2[DC$cluster==uni[uni_id]] = as.numeric(DC$mode[as.character(uni[uni_id])])\n           }\n           \n           I[root_id]=root_id[I2]\n           W[root_id]=0\n           Hnnd_root_id =which(I==c(1:N))\n         },\n         # hnnd valley based distance ---------------------------------------------------------------\n         \"Hnnd_valley_based_distance\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           print(paste(knn_method,\" knn \"))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    \n                    ann = hnsw_build(x,disName)\n                    knn = hnsw_search(x,ann,K+1)\n                    \n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"PR_tree\" = {\n                    tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    \n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           print(\"density estimation...\")\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           } else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           print(\"1st round NND:\")\n           \n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           \n           I=nnd$I\n           W=nnd$W\n           \n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           \n           print(\"other round NND:\")\n           \n           while(1){\n             \n             if (length(root_id) <= h) break\n             \n             R_num_each_layer[layer] = print(length(root_id))\n             listRootIndEachLayer [[layer]] = root_id\n             \n             \n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      Kd_tree_construction <- WKNNF(x[root_id,])\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"hnsw\" = {\n                      ann = hnsw_build(x[root_id,],disName)\n                      knn = hnsw_search(x[root_id,],ann,K+1)\n                      \n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"PR_tree\" = {\n                      tree.index = ConstructKnnRandomProjection(x[root_id,],NumT,disName)\n                      knn = queryKnnRandomProjection(tree.index,1:length(root_id),K)\n                      \n                    }\n             )\n             \n             \n             \n             if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               nnd = NND_no_density_estimation_V1_memory_saving(Density_initial[root_id],knn)\n               I[root_id]=root_id[nnd$I]\n               \n               W[root_id]=nnd$W\n               \n               root_id = root_id[nnd$W_Max_idx]\n             }else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               \n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           \n           \n           \n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           \n           Hnnd_root_id = root_id\n           \n           \n           \n           \n           Res=lift_time_based_ND_v3(W,I,Density_initial,knn_initial$nn.index,root_id)\n           \n           \n           \n           \n           I[root_id] = root_id[Res$I]\n           W[root_id] = Res$W\n           Hnnd_root_id = which(I==c(1:N))\n         },\n         # Dnnd ---------------------------------------------------------------\n         \"Dnnd\"={\n           N = nrow(x)\n           Dim = ncol(x)\n           I = vector(length = N)\n           W = vector(length = N)\n           P_Amp = vector(length = N)\n           root_id = c(1:N)\n           while_t = 1\n           while (length(root_id)!=1){\n             if (length(root_id)>K){\n               # nnd=NND_k(x[root_id,],K,alpha)\n               nnd=NND_k_V2(x[root_id,],K,alpha,knn_method = knn_method,densityMethod)\n               if (while_t == 1){\n                 knn_initial = nnd$knn\n                 nnd_root_initial = nnd$W_Max_idx\n               }\n               I[root_id]=root_id[nnd$I]\n               W[root_id]=nnd$W\n               P_Amp[root_id] = nnd$P_Amp\n               root_id = root_id[nnd$W_Max_idx]\n             } else{\n               H_P_Amp=P_Amp[root_id]\n               nd=ND_FeatureSpace(H_P_Amp,x[root_id,])\n               I[root_id]=root_id[nd$I]\n               W[root_id]=nd$W\n               root_id =root_id[nd$root]\n             }\n             while_t = while_t + 1\n             K = max(ceiling(log2(K)),3)\n             # K = max(ceiling(K*2),3)\n           }\n           Hnnd_root_id = root_id\n         },\n         # NNA ---------------------------------------------------------------\n         \"NNA\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    \n                    ann = hnsw_build(x,disName)\n                    knn = hnsw_search(x,ann,K+1)\n                    \n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"PR_tree\" = {\n                    tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    \n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           print(\"density estimation...\")\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           } else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           print(\"1st round NND:\")\n           \n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           \n           I=nnd$I\n           W=nnd$W\n           \n           root_id = nnd$W_Max_idx\n           \n           Hnnd_root_id = nnd$W_Max_idx\n         },\n         # NA ---------------------------------------------------------------\n         \"NA\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           # knnDensity=density_estimation_from_density_cut(x,K,alpha)\n           \n           # nd=ND_less_space_consumption(knnDensity$P_Amp,x,disName)\n           \n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    \n                    ann = hnsw_build(x,disName)\n                    knn = hnsw_search(x,ann,K+1)\n                    \n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"PR_tree\" = {\n                    tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    \n                  }\n           )\n           \n           \n           \n           \n           knn_initial = knn\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           \n           nd=ND_less_space_consumption(Density_initial,x,disName)\n           \n           \n           \n           I=nd$I\n           W=nd$W\n           Hnnd_root_id = nd$root\n         },\n         # NA+ ---------------------------------------------------------------\n         \"NA+\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           # nnd=NND_k(x,K,alpha,knn_method = knn_method)\n           nnd=NND_k_V2(x,K,alpha,knn_method = knn_method,densityMethod = densityMethod)\n           Density_initial = nnd$P_Amp\n           I=nnd$I\n           W=nnd$W\n           knn_initial = nnd$knn\n           \n           nnd_root_initial = nnd$W_Max_idx\n           \n           root_id = nnd$W_Max_idx\n           nnd_root_initial = root_id\n           print(paste(\"number of root nodes:\",length(root_id),sep = \"\"))\n           \n           nd=ND_subset(nnd$P_Amp,x,root_id)\n           \n           I[root_id]=nd$I\n           W[root_id]=nd$W\n           Hnnd_root_id =nd$root\n         },\n         # NA++ ---------------------------------------------------------------\n         \"NA++\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           \n           print(paste0('fast knn (',knn_method,')...'))\n           switch(knn_method,\n                  \"kd_tree\" = {\n                    if (reuse_tree_contruction == \"on\") {\n                      # filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                      # load(filename)\n                      # message(\"directly Load knn graph built by kd_tree\")\n                      message(\"Kd_tree_construction cannot be loaded; thus the kd-tree has to be constructed again\")\n                      Kd_tree_construction <- WKNNF(x)\n                    } else {\n                      Kd_tree_construction <- WKNNF(x)\n                    }\n                    \n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                    filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                    # save.image(file = filename)\n                  },\n                  \"cover_tree\" = {\n                    knn <- FNN::get.knnx(x,x,k = K+1, algo = 'cover_tree')\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      message(\"directly Load knn graph built by hnsw...\")\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                     \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      ann$save(filename)\n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                       \n                    }\n                    \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){ \n                      if (disName == \"euclidean\"){\n                        filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                        tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      } else {\n                        stop('distance metric not supported')\n                      }\n                      \n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    if (disName == \"euclidean\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                    } else {\n                      stop('distance metric not supported')\n                    }\n                    tree.index$save(filename)\n                  }\n           )\n           \n            \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"simple_knn_square\"){\n             Density_initial = simlified_knn_density_estimation_v2(knn,K)\n           } else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n            \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           \n           knn_initial = knn\n           nnd_root_initial = nnd$W_Max_idx\n           \n           root_id = nnd$W_Max_idx\n           \n           T =h\n           \n           layer = 1\n           while(length(root_id)!=1){\n             R_num_each_layer[layer] = print(length(root_id))\n             if ((length(root_id)>T)&(min(Density_initial[root_id])!=max(Density_initial[root_id]))){\n               \n               K = min(K*4,N-1) \n               switch(knn_method,\n                      \"kd_tree\" = {\n                        knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                        names(knn)[1] <- \"nn.index\"\n                        names(knn)[2] <- \"nn.dist\"\n                        knn$nn.index = knn$nn.index[,-1]\n                        knn$nn.dist = knn$nn.dist[,-1]\n                      },\n                      \"cover_tree\" = {\n                        knn <- get.knnx(x,x[root_id,],k = K+1, algo = 'cover_tree')\n                        knn$nn.index = knn$nn.index[,-1]\n                        knn$nn.dist = knn$nn.dist[,-1]\n                      },\n                      \"hnsw\" = {\n                        knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                      },\n                      \"PR_tree\" = {\n                        knn = queryKnnRandomProjection(tree.index,root_id,K)\n                      }\n               )\n               \n                \n              \n               \n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               \n               nnd = NND_no_density_estimation_subset_v2_memory_saving(Density_initial,knn,root_id)\n               I[root_id]=nnd$I\n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n               \n             }else{\n               nd=ND_subset(Density_initial,x,root_id,disName)\n               \n               I[root_id]=nd$I\n               W[root_id]=nd$W\n               k_all[root_id] = max(k_all[-root_id])\n               \n               root_id =nd$root\n             }\n             layer = layer + 1\n           }\n           R_num_each_layer[layer] = length(root_id)\n           # print(length(root_id))\n           Hnnd_root_id = root_id\n         },\n         # NA++(with_th_increasing) ---------------------------------------------------------------\n         \"NA++(with_th_increasing)\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    if (reuse_tree_contruction == \"on\") {\n                      # filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                      # load(filename)\n                      # message(\"directly Load knn graph built by kd_tree\")\n                      message(\"Kd_tree_construction cannot be loaded; thus the kd-tree has to be constructed again\")\n                      Kd_tree_construction <- WKNNF(x)\n                    } else {\n                      Kd_tree_construction <- WKNNF(x)\n                    }\n                    \n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                    filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                    # save.image(file = filename)\n                  },\n                  \"cover_tree\" = {\n                    knn <- FNN::get.knnx(x,x,k = K+1, algo = 'cover_tree')\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      message(\"directly Load knn graph built by hnsw...\")\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      ann$save(filename)\n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                    }\n                    \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){ \n                      if (disName == \"euclidean\"){\n                        filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                        tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      } else {\n                        stop('distance metric not supported')\n                      }\n                      \n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    if (disName == \"euclidean\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                    } else {\n                      stop('distance metric not supported')\n                    }\n                    tree.index$save(filename)\n                  }\n           )\n           \n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"simple_knn_square\"){\n             Density_initial = simlified_knn_density_estimation_v2(knn,K)\n           } else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           \n           knn_initial = knn\n           nnd_root_initial = nnd$W_Max_idx\n           \n           root_id = nnd$W_Max_idx\n           \n           T =h\n           \n           layer = 1\n           count = 0 \n           while(length(root_id)!=1){\n             R_num_each_layer[layer] = print(length(root_id))\n             if (layer > 1){\n               if (R_num_each_layer[layer] == R_num_each_layer[layer-1]){\n                 count = count + 1\n                 if (count>3){\n                   T = T*2 \n                 }\n               }  \n             }\n             if ((length(root_id)>T)&(min(Density_initial[root_id])!=max(Density_initial[root_id]))){\n               \n               K = min(K*4,N-1) \n               switch(knn_method,\n                      \"kd_tree\" = {\n                        knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      },\n                      \"cover_tree\" = {\n                        knn <- get.knnx(x,x[root_id,],k = K+1, algo = 'cover_tree')\n                        knn$nn.index = knn$nn.index[,-1]\n                        knn$nn.dist = knn$nn.dist[,-1]\n                      },\n                      \"hnsw\" = {\n                        knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                      },\n                      \"PR_tree\" = {\n                        knn = queryKnnRandomProjection(tree.index,root_id,K)\n                      }\n               )\n               \n               \n               names(knn)[1] <- \"nn.index\"\n               names(knn)[2] <- \"nn.dist\"\n               knn$nn.index = knn$nn.index[,-1]\n               knn$nn.dist = knn$nn.dist[,-1]\n               \n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               \n               nnd = NND_no_density_estimation_subset_v2_memory_saving(Density_initial,knn,root_id)\n               I[root_id]=nnd$I\n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n               \n             }else{\n               nd=ND_subset(Density_initial,x,root_id,disName)\n               \n               I[root_id]=nd$I\n               W[root_id]=nd$W\n               k_all[root_id] = max(k_all[-root_id])\n               \n               root_id =nd$root\n             }\n             layer = layer + 1\n           }\n           R_num_each_layer[layer] = length(root_id)\n           # print(length(root_id))\n           Hnnd_root_id = root_id\n         },\n         # NA++_HNND ---------------------------------------------------------------\n         \"NA++HNND\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    if (reuse_tree_contruction == \"on\") {\n                      # filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                      # load(filename)\n                      # message(\"directly Load knn graph built by kd_tree\")\n                      message(\"Kd_tree_construction cannot be loaded; thus the kd-tree has to be constructed again\")\n                      Kd_tree_construction <- WKNNF(x)\n                    } else {\n                      Kd_tree_construction <- WKNNF(x)\n                    }\n                    \n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                    filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                    # save.image(file = filename)\n                  },\n                  \"cover_tree\" = {\n                    knn <- FNN::get.knnx(x,x,k = K+1, algo = 'cover_tree')\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      message(\"directly Load knn graph built by hnsw...\")\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      ann$save(filename)\n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                    }\n                    \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){ \n                      if (disName == \"euclidean\"){\n                        filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                        tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      } else {\n                        stop('distance metric not supported')\n                      }\n                      \n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    if (disName == \"euclidean\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                    } else {\n                      stop('distance metric not supported')\n                    }\n                    tree.index$save(filename)\n                  }\n           )\n           \n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"simple_knn_square\"){\n             Density_initial = simlified_knn_density_estimation_v2(knn,K)\n           } else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           \n           knn_initial = knn\n           nnd_root_initial = nnd$W_Max_idx\n           \n           root_id = nnd$W_Max_idx\n           \n           T =h\n           \n           layer = 1\n           while(length(root_id)!=1){\n             R_num_each_layer[layer] = print(length(root_id))\n             if ((length(root_id)>T)&(min(Density_initial[root_id])!=max(Density_initial[root_id]))){\n               \n               K = min(K*4,N-1) \n               switch(knn_method,\n                      \"kd_tree\" = {\n                        knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                        names(knn)[1] <- \"nn.index\"\n                        names(knn)[2] <- \"nn.dist\"\n                        knn$nn.index = knn$nn.index[,-1]\n                        knn$nn.dist = knn$nn.dist[,-1]\n                      },\n                      \"cover_tree\" = {\n                        knn <- get.knnx(x,x[root_id,],k = K+1, algo = 'cover_tree')\n                        knn$nn.index = knn$nn.index[,-1]\n                        knn$nn.dist = knn$nn.dist[,-1]\n                      },\n                      \"hnsw\" = {\n                        knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                      },\n                      \"PR_tree\" = {\n                        knn = queryKnnRandomProjection(tree.index,root_id,K)\n                      }\n               )\n               \n               \n                \n               \n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               \n               nnd = NND_no_density_estimation_subset_v2_memory_saving(Density_initial,knn,root_id)\n               I[root_id]=nnd$I\n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n               \n             }else{\n                \n               nd=ND_less_space_consumption(Density_initial[root_id],x[root_id,],disName)\n               I[root_id]=root_id[nd$I]\n               W[root_id]=nd$W\n               k_all[root_id] = max(k_all[-root_id])\n                \n               root_id =which(I==c(1:N))\n             }\n             layer = layer + 1\n           }\n           R_num_each_layer[layer] = length(root_id)\n           # print(length(root_id))\n           Hnnd_root_id = root_id\n         },\n         # NA++ (ne.mem.) ---------------------------------------------------------------\n         \"NA++ (ne.mem.)\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      message(\"directly Load knn graph built by hnsw...\")\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                    \n                    } else{\n                      ann = hnsw_build(x,disName)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')   \n                      ann$save(filename)\n                    }\n                  },\n                  \"PR_tree\" = {\n                    stop(\"PR_tree is not appropriate for this method\")\n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           T = h\n           while(length(root_id)!=1){\n             \n             if ((length(root_id)>T)&(min(Density_initial[root_id])!=max(Density_initial[root_id]))){\n               \n               R_num_each_layer[layer] = print(length(root_id))\n               listRootIndEachLayer [[layer]] = root_id\n               k_old = K\n               K = min(K*4,N-1)\n               \n               \n               switch(knn_method,\n                      \"kd_tree\" = {\n                        knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                        names(knn)[1] <- \"nn.index\"\n                        names(knn)[2] <- \"nn.dist\"\n                        knn$nn.index = knn$nn.index[,-1]\n                        knn$nn.dist = knn$nn.dist[,-1]\n                      },\n                      \"hnsw\" = {\n                        knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                      },\n                      \"PR_tree\" = {\n                        knn = queryKnnRandomProjection(tree.index,root_id,K)\n                      }\n               )\n               \n               \n               nnd = NND_no_denEsti_subset_memory_saving_and_diff_mechanism(Density_initial,knn,K,k_old,root_id)\n               \n               I[root_id]=nnd$I\n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n             }else{\n               print(length(root_id))\n                \n               nd = ND_subset_with_Memory(Density_initial,x,root_id,knn)\n               \n               I[root_id]=nd$I\n               W[root_id]=nd$W\n               root_id =nd$root\n             }\n             layer = layer + 1 \n           }\n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           k_all[root_id] = max(k_all[-root_id])\n           \n           Hnnd_root_id = root_id\n         },\n         # NA+++ ---------------------------------------------------------------\n         \"NA+++\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    if (reuse_tree_contruction == \"on\") {\n                      # filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                      # load(filename)\n                      # message(\"directly Load knn graph built by kd_tree\")\n                      message(\"Kd_tree_construction cannot be loaded; thus the kd-tree has to be constructed again\")\n                      Kd_tree_construction <- WKNNF(x)\n                    } else {\n                      Kd_tree_construction <- WKNNF(x)\n                    }\n                    \n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                    filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                    # save.image(file = filename)\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      \n                      if (file.exists(filename)){\n                        if (disName == \"euclidean\"){\n                          ann <- new(HnswL2, Dim, filename)\n                        } else if (disName == \"cosine\") {\n                          ann <- new(HnswCosine, Dim, filename)\n                        } \n                        message(\"directly Load knn graph built by hnsw...\")\n                        knn = queryKnnHNSW(ann,x,K+1,disName)\n                      } else {\n                        stop(\"knn graph has never been built before; so, turn 'on' to 'off' \")\n                      }  \n                    } else{\n                      ann = hnsw_build(x,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      ann$save(filename)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                    }\n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                      tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                    tree.index$save(filename)\n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           print(\"density estimation...\")\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           \n         \n           \n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           while(1){\n             \n             if (length(root_id) <= Threshold_RootNum) break\n             \n             R_num_each_layer[layer] = print(length(root_id))\n             listRootIndEachLayer [[layer]] = root_id\n             K = min(K*4,N-1)\n             print(K)\n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n\n\n\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                      \n                       \n                    },\n                    \"hnsw\" = {\n                      knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                    },\n                    \"PR_tree\" = {\n                      knn = queryKnnRandomProjection(tree.index,root_id,K)\n                    }\n             )\n             \n             \n             \n             if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n               # nnd = NND_no_density_estimation_subset_v2(Density_initial,knn,K,root_id)\n               nnd = NND_no_density_estimation_subset_v2_memory_saving(Density_initial,knn,root_id)\n               I[root_id]=nnd$I\n               \n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n             }else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               k_all[root_id] = K\n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           \n           \n           \n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           k_all[root_id] = max(k_all[-root_id])\n           Hnnd_root_id = root_id\n         },\n         # NA+++ (ne.mem.) ---------------------------------------------------------------\n         \"NA+++ (ne.mem.)\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      message(\"directly Load knn graph built by hnsw...\")\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')   \n                      ann$save(filename)\n                    }\n                     \n                  },\n                  \"PR_tree\" = {\n                    stop(\"PR_tree is not appropriate for this method\")\n                    \n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           while(1){\n             \n             if (length(root_id) <= Threshold_RootNum) break\n             \n             R_num_each_layer[layer] = print(length(root_id))\n             listRootIndEachLayer [[layer]] = root_id\n             k_old = K\n             K = min(K*4,N-1)\n             \n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"hnsw\" = {\n                      knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                    },\n                    \"PR_tree\" = {\n                      knn = queryKnnRandomProjection(tree.index,root_id,K)\n                    }\n             )\n             \n             if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n               # nnd = NND_no_dens_esti_subset_v3_differece_mechanism(Density_initial,knn,K,k_old,root_id)\n               \n               nnd = NND_no_denEsti_subset_memory_saving_and_diff_mechanism(Density_initial,knn,K,k_old,root_id)\n               \n               I[root_id]=nnd$I\n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n             } else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               k_all[root_id] = K\n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           k_all[root_id] = max(k_all[-root_id])\n           Hnnd_root_id = root_id\n         },\n         # NA+++ (ne.mem.) with cluster number specified ---------------------------------------------------------------\n         \"NA+++ (ne.mem.) with cluster number\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                      load(filename)\n                      message(\"directly Load knn graph built by kd-tree\")\n                    } else{\n                      Kd_tree_construction <- WKNNF(x)\n                    }\n                    \n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                    filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                    save(file = filename,Kd_tree_construction)\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      message(\"directly Load knn graph built by hnsw...\")\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      ann$save(filename)\n                      \n                    }\n                     \n                  },\n                  \"PR_tree\" = {\n                    stop(\"PR_tree is not appropriate for this method\")\n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           while(1){\n             \n             if (length(root_id) <= ClustN) break\n             \n             R_num_each_layer[layer] = print(length(root_id))\n             listRootIndEachLayer [[layer]] = root_id\n             k_old = K\n             K = min(K*4,N-1)\n             \n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"hnsw\" = {\n                      knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                    },\n                    \"PR_tree\" = {\n                      knn = queryKnnRandomProjection(tree.index,root_id,K)\n                    }\n             )\n             \n             if (min(Density_initial[root_id])!=max(Density_initial[root_id])){\n               # nnd = NND_no_dens_esti_subset_v3_differece_mechanism(Density_initial,knn,K,k_old,root_id)\n               \n               nnd = NND_no_denEsti_subset_memory_saving_and_diff_mechanism(Density_initial,knn,K,k_old,root_id)\n                \n               I[root_id]=nnd$I\n               W[root_id]=nnd$W\n               k_all[root_id] = nnd$K_optimal\n               root_id = nnd$W_Max_idx\n             }else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               k_all[root_id] = K\n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           k_all[root_id] = max(k_all[-root_id])\n           Hnnd_root_id = root_id\n         },\n         # NA+++DensityUpdate ---------------------------------------------------------------\n         \"NA+++DensityUpdate\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      message(\"directly Load knn graph built by hnsw...\")\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')   \n                      ann$save(filename)\n                    }\n                     \n                    \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                      tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                      # tree.index$save(filename)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    \n                  }\n           )\n           \n           \n           \n           knn_initial = knn\n           print(\"density estimation...\")\n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           \n           print(\"NNA:\")\n           \n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           layer = 1\n           while(1){\n             \n             if (length(root_id) <= Threshold_RootNum) break\n             \n             R_num_each_layer[layer] = print(length(root_id))\n             listRootIndEachLayer [[layer]] = root_id\n             K = min(K+2,N-1)\n             \n             \n             switch(knn_method,\n                    \"kd_tree\" = {\n                      knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n                      names(knn)[1] <- \"nn.index\"\n                      names(knn)[2] <- \"nn.dist\"\n                      knn$nn.index = knn$nn.index[,-1]\n                      knn$nn.dist = knn$nn.dist[,-1]\n                    },\n                    \"hnsw\" = {\n                      knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)\n                    },\n                    \"PR_tree\" = {\n                      knn = queryKnnRandomProjection(tree.index,root_id,K)\n                    }\n             )\n             \n             \n             print(\"density update:\")\n             if (densityMethod == 'RW_knn'){\n               Density_roots = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n             }else if (densityMethod == \"st_knn\"){\n               Density_roots = standard_knn_density_estimation(knn,K,Dim)\n             }else if (densityMethod == \"simple_knn\"){\n               Density_roots = simlified_knn_density_estimation_v1(knn,K)\n             } else {\n               stop(\"no matched density estimation method\")\n             }\n             if (min(Density_roots)!=max(Density_roots)){\n               K2 = min(K,length(root_id)-1)\n               switch(knn_method,\n                      \"kd_tree\" = {\n                        Kd_tree_construction2 <- WKNNF(x[root_id,])\n                        knn2 <- Kd_tree_construction2$query(x[root_id,], k=K2+1, eps=0, radius=0)\n                        names(knn2)[1] <- \"nn.index\"\n                        names(knn2)[2] <- \"nn.dist\"\n                        knn2$nn.index = knn2$nn.index[,-1]\n                        knn2$nn.dist = knn2$nn.dist[,-1]\n                      },\n                      \"hnsw\" = {\n                        ann2 = hnsw_build(x[root_id,],disName)\n                        knn2 = hnsw_search(x[root_id,],ann2,K2+1)\n                        \n                        names(knn2)[1] <- \"nn.index\"\n                        names(knn2)[2] <- \"nn.dist\"\n                        knn2$nn.index = knn2$nn.index[,-1]\n                        knn2$nn.dist = knn2$nn.dist[,-1]\n                      },\n                      \"PR_tree\" = {\n                        tree.index2 = ConstructKnnRandomProjection(x[root_id,],NumT,disName)\n                        knn2 = queryKnnRandomProjection(tree.index2,1:length(root_id),K2)\n                        \n                      }\n               )\n               \n               nnd = NND_no_density_estimation_V1_memory_saving(Density_roots,knn2)\n               \n               I[root_id]=root_id[nnd$I]\n               W[root_id]=nnd$W\n               root_id = root_id[nnd$W_Max_idx]\n             }else{\n               I[root_id]=min(root_id)\n               W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n               \n               root_id = min(root_id)\n             }\n             layer = layer + 1 \n           }\n           \n           \n           \n           R_num_each_layer[layer] = print(length(root_id))\n           listRootIndEachLayer [[layer]] = root_id\n           \n           \n           Hnnd_root_id = root_id\n         },\n         # McoresHNNA ---------------------------------------------------------------\n         \"McoresHNNA\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           print(paste0('fast knn (',knn_method,')...'))\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    Kd_tree_construction <- WKNNF(x)\n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      message(\"directly Load knn graph built by hnsw...\")\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')   \n                      ann$save(filename)\n                    }\n                     \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                      tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                      # tree.index$save(filename)\n                    }\n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    \n                  }\n           )\n           \n           \n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           \n           # nnd = NND_no_density_estimation(Density_initial,knn,K)\n           nnd = NND_no_density_estimation_V1_memory_saving(Density_initial,knn)\n           \n           I=nnd$I\n           W=nnd$W\n           k_all = nnd$K_optimal\n           root_id = nnd$W_Max_idx\n           nnd_root_initial = nnd$W_Max_idx\n           \n           print(c(\"root number by 1st round NNA: \", length(root_id)))\n           b= data.frame(from = rep(1:N,times = K),to = as.vector(knn$nn.index))\n           g=graph_from_data_frame(b)\n           \n           \n           gm=delete.edges(g,E(g)[!which_mutual(g)])\n           \n           # plot(g,vertex.size=6,vertex.label=NA, edge.label=NA, edge.arrow.size = 0.1)\n           \n           print(\"select the cluster centers: \")\n           \n           beta = 0.95\n           M = vector()\n           c = vector()\n           R = root_id\n           f = Density_initial[R]\n           f_order = order(f,decreasing=TRUE)\n           Hnnd_root_id = f_order[1]\n           for (i in 1:length(R)){\n             idx = f_order[i]\n             if (!is.element(R[idx],M)){\n               lamda = (1-beta)*f[idx]\n               gml = delete.vertices(gm,V(gm)[Density_initial<lamda])\n               \n               \n               A = subcomponent(gml,which(as.numeric(as_ids(V(gml)))==R[idx]))\n               A = as.numeric(as_ids(A))\n               if (length(intersect(A,M))==0){\n                 \n                 \n                 c = union(c,R[idx])\n                 I[R[idx]] = R[idx]\n                 M = union(M,intersect(A,R))\n                 for (j in setdiff(intersect(A,R),R[idx])){\n                   I[j] = R[idx]\n                 }\n               }\n             }\n           }\n           \n           \n           \n           # method 1\n           print(\"assign the rest nodes: \")\n           \n           root_id = setdiff(R,M)\n           if (length(root_id)>1){\n             nd=ND_subset_no_root_output(Density_initial,x,root_id)\n             I[root_id]=nd$I\n             W[root_id]=nd$W\n           }\n           \n           \n           \n           # method 2\n           # \n           #            k_old = K\n           #            K = min(K*4,N-1)\n           # \n           #            switch(knn_method,\n           #                   \"kd_tree\" = {\n           #                     knn <- Kd_tree_construction$query(x[root_id,], k=K+1, eps=0, radius=0)\n           #                     names(knn)[1] <- \"nn.index\"\n           #                     names(knn)[2] <- \"nn.dist\"\n           #                     knn$nn.index = knn$nn.index[,-1]\n           #                     knn$nn.dist = knn$nn.dist[,-1]\n           #                   },\n           #                   \"hnsw\" = {\n           #                     knn = queryKnnHNSW(ann,x[root_id,],K+1,disName)           #                     \n           #                   },\n           #                   \"PR_tree\" = {\n           #                     knn = queryKnnRandomProjection(tree.index,root_id,K)\n           #                   }\n           #            )\n           #            print(\"assign the rest nodes: \")\n           #            \n           # \n           #            root_id = setdiff(R,M)\n           #            if (length(root_id)>1){\n           # \n           #              # nnd = NND_no_dens_esti_subset_v3_differece_mechanism(Density_initial,knn,K,k_old,root_id)\n           # \n           #              nnd = NND_no_denEsti_subset_memory_saving_and_diff_mechanism(Density_initial,knn,K,k_old,root_id)\n           # \n           #              I[root_id]=nnd$I\n           #              W[root_id]=nnd$W\n           #              k_all[root_id] = nnd$K_optimal\n           #              root_id = nnd$W_Max_idx\n           #            }else{\n           #              I[root_id]=min(root_id)\n           #              W[root_id]= apply(x[root_id,],1,function(z,y=x[min(root_id),]) (sum((z-y)^2))^0.5)\n           #              k_all[root_id] = K\n           #              root_id = min(root_id)\n           #            }\n           #            \n           #            \n           #            \n           \n         },\n         # Dynamic_Levelset_plus_NNA ---------------------------------------------------------------\n         \"DyLS_NNA\" = {\n           N = nrow(x)\n           Dim = ncol(x)\n           k_all = vector(length = N)\n           \n           switch(knn_method,\n                  \"kd_tree\" = {\n                    if (reuse_tree_contruction == \"on\") {\n                      # filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                      # load(filename)\n                      # message(\"directly Load knn graph built by kd_tree\")\n                      message(\"Kd_tree_construction cannot be loaded; thus the kd-tree has to be constructed again\")\n                      Kd_tree_construction <- WKNNF(x)\n                    } else {\n                      Kd_tree_construction <- WKNNF(x)\n                    }\n                    \n                    knn <- Kd_tree_construction$query(x, k=K+1, eps=0, radius=0)\n                    names(knn)[1] <- \"nn.index\"\n                    names(knn)[2] <- \"nn.dist\"\n                    knn$nn.index = knn$nn.index[,-1]\n                    knn$nn.dist = knn$nn.dist[,-1]\n                    filename = paste(\"KD_tree_build_\",data_name,\".Rdata\",sep = '')\n                    # save.image(file = filename)\n                  },\n                  \"hnsw\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      if (disName == \"euclidean\"){\n                        ann <- new(HnswL2, Dim, filename)\n                      } else if (disName == \"cosine\") {\n                        ann <- new(HnswCosine, Dim, filename)\n                      } \n                      \n                      \n                      message(\"directly Load knn graph built by hnsw...\")\n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                    } else{\n                      ann = hnsw_build(x,disName)\n                      filename = paste(\"hnsw_build_\",disName,'_',data_name,sep = '')\n                      ann$save(filename)\n                      \n                      knn = queryKnnHNSW(ann,x,K+1,disName)\n                      \n                    } \n                  },\n                  \"PR_tree\" = {\n                    if (reuse_tree_contruction == \"on\"){\n                      filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                      tree.index <- new(AnnoyEuclidean, Dim)           \t# new object, could be in another process\n                      tree.index$load(filename)\n                      message(\"directly Load knn graph built by PR_tree\")\n                    }else{\n                      tree.index = ConstructKnnRandomProjection(x,NumT,disName)\n                    }\n                    \n                    knn = queryKnnRandomProjection(tree.index,1:N,K)\n                    filename = paste(\"PR_tree_build_\",data_name,sep = '')\n                    tree.index$save(filename)\n                  }\n           )\n           \n           \n           if (densityMethod == 'RW_knn'){\n             Density_initial = density_estimation_from_density_cut_V3(knn,N,Dim,K,alpha)\n           }else if (densityMethod == \"st_knn\"){\n             Density_initial = standard_knn_density_estimation(knn,K,Dim)\n           }else if (densityMethod == \"simple_knn\"){\n             Density_initial = simlified_knn_density_estimation_v1(knn,K)\n           } else if (densityMethod == \"simple_knn_square\"){\n             Density_initial = simlified_knn_density_estimation_v2(knn,K)\n           } else if (densityMethod == \"truncatedKDE\"){\n             Density_initial = truncated_kernel_density_estimation_v1(knn,K)\n           } else {\n             stop(\"no matched density estimation method\")\n           }\n           \n           # Define the global variables\n           # I <<- 1:N\n           # RA <<- rep(0,length = N)\n           # knn_initial = knn\n           # RE = DyLevelSet_NNA_in_one_stage3(x = x,knn = knn,f = Density_initial,I=I,RA =RA) \n           \n           knn_initial = knn\n \n           a = DyLevelSet_NNA_in_one_stage_V2_different_knn(x = x,knn = knn,f = Density_initial,knn_type = knn_type)\n           Hnnd_root_id = a$root_id[1]\n           \n           I = a$I_forInTree \n            \n           W = a$W_forInTree\n           \n           ratio = a$Q[a$NNA_root_id]\n           M = length(unique(annotation_data)) - (length(a$NNA_root_id) - length(a$roots_merged))\n           \n           \n           if (M<length(a$NNA_root_id)){\n             if (M>0) {\n               peaks = vector()\n               for (i in 1:M){\n                 idx =which.max(ratio)\n                 peaks = c(peaks,a$NNA_root_id[idx])\n                 ratio[idx] = -Inf\n               } \n               I[peaks] = peaks\n               \n               \n               \n               \n               Q_sort = sort(a$Q[a$NNA_root_id],decreasing = TRUE)\n               plot(Q_sort)\n               points(Q_sort[1:M],col = 'red',pch = 16)\n                \n               \n             }\n           } else {\n             # method 1: whole data\n             # ratio = a$Q\n             # M = length(unique(annotation_data)) - length(which(a$I_forInTree==c(1:N)))\n             # \n             # for (i in 1:M){\n             #   idx =which.max(ratio)\n             #   I[idx]=idx\n             #   ratio[idx] = -Inf\n             # }\n             # \n             # Q_sort = sort(a$Q,decreasing = TRUE)\n             # plot(Q_sort)\n             # points(Q_sort[1:M],col = 'red',pch = 16)\n             \n             # METHOD 2\n             \n             I[a$NNA_root_id] = a$NNA_root_id\n             \n             \n             ratio = a$Q\n             ratio[a$NNA_root_id] = -Inf\n             \n             # M = length(unique(annotation_data)) - length(which(a$I_forInTree==c(1:N)))\n             M = length(unique(annotation_data)) - length(a$NNA_root_id)\n             \n             for (i in 1:M){\n               idx =which.max(ratio)\n               I[idx]=idx\n               ratio[idx] = -Inf\n             }\n             \n             Q_sort = sort(Q,decreasing = TRUE)\n             plot(Q_sort)\n             points(Q_sort[1:M],col = 'red',pch = 16)\n             \n           }\n         }\n  )\n  \n  I_forInTree = I\n  W_forInTree = W\n  I_after_root_search = NaN\n  # Cut edges ---------------------------------------------------------------\n  Totoltime_DG = 0\n  \n  if (any(InTree_construction_method_id == c('DyLS_NNA',\"NNA\",\"NND\",\"McoresHNNA\",\"Combine_HNND_Densitycut\"))){\n    I_old=I\n    I=I_old[I_old]\n    while(sum(as.numeric(I-I_old))){\n      I_old=I\n      I=I_old[I_old]\n    }\n    Label = I\n    \n  } else if (InTree_construction_method_id == \"Hnnd_valley_based_distance\") {\n    temp = list()\n    temp$W_forInTree = W_forInTree[root_id]\n    temp$I_forInTree = I_forInTree[root_id]\n    temp$Density_initial = Density_initial[root_id]\n    result = interactive_determine_the_threshold_based_on_W_and_density(temp)\n    peaks = result$peaks\n    peaks = root_id[peaks]\n    \n    I[peaks]=peaks\n    \n    print(\"dynamic update the parent node...\")\n    \n    I_old=I\n    I=I_old[I_old]\n    while(sum(as.numeric(I-I_old))){\n      I_old=I\n      I=I_old[I_old]\n    }\n    \n    \n    \n    # cluster assignment\n    Label = I\n  } else {\n    switch(intercluster_edges_method_id,\n           DG = {\n             # graphics.off()\n             dev.new()\n             Totoltime_DG<-system.time({\n               temp = list()\n               temp$W_forInTree = W_forInTree\n               temp$I_forInTree = I_forInTree\n               temp$Density_initial = Density_initial\n               temp$Hnnd_root_id = Hnnd_root_id\n               result = interactive_determine_the_threshold_based_on_W_and_density(temp,Log = 'xy')\n               peaks = result$peaks\n               title(paste0(data_name,', ',disName,', K = ',K_initial))\n             })[3]\n             # dev.off()\n           },\n           DG_sampling = {\n             temp = list()\n             temp$W_forInTree = W_forInTree\n             temp$I_forInTree = I_forInTree\n             temp$Density_initial = Density_initial\n             temp$Hnnd_root_id = Hnnd_root_id\n             if (exists(\"k_all\")){\n               temp$k_all = k_all\n               save(file = paste(\"intermediate_result.Rdata\",sep = \"\"),temp,thresh_k,W,I)\n               result = interactive_determine_the_density_peaks_Time_and_Space_effecient(temp,thresh_k = thresh_k)\n             } else {\n               message(\"there is no k_all variable; sampling cannot be used\")\n               result = interactive_determine_the_threshold_based_on_W_and_density(temp)\n             }\n             \n             peaks = result$peaks\n           },\n           D_ratio = {\n             Me=cbind(knn_initial$nn.dist,knn_initial$nn.dist[I,])\n             Me = rowMeans(Me)\n             ratio= Me/W\n             ratio[Hnnd_root_id]=0\n           },\n           D_ratio_DeltaRho = {\n              \n             ratio= 1/(W*Density_initial)\n             ratio[Hnnd_root_id]=0\n           },\n           D_ratio2 = {\n             Me=cbind(knn_initial$nn.dist[,10],knn_initial$nn.dist[I,10])\n             Me = rowMeans(Me)\n             ratio= Me/W\n             ratio[Hnnd_root_id]=0\n           },\n           D_ratio3 = { \n             Me = rowMeans(knn_initial$nn.dist)\n             ratio= Me/W\n             ratio[Hnnd_root_id]=0\n           },\n           boxplot_based ={\n             sta = boxplot(k_all)\n             peaks=which(k_all>sta$stats[5])\n             \n           },\n           Ratio_1nnVsG1nn = {\n             Me = rowMeans(knn_initial$nn.dist)\n             ratio= Me/W\n             ratio[Hnnd_root_id]=0\n           },\n           M2 = {\n             Me_means_1 = rowMeans(knn_initial$nn.dist)\n             Me_means_2 = rowMeans(knn_initial$nn.dist[I,])\n             Me=cbind(Me_means_1,Me_means_2)\n             Me_means = pmax(Me_means_1,Me_means_2)\n             ratio= Me_means/W\n             ratio[Hnnd_root_id]=0\n           },\n           M3 = {\n             Me=cbind(knn_initial$nn.dist,knn_initial$nn.dist[I,])\n             Me2 = matrix(nrow = N,ncol = 1)\n             for (i in 1:N){\n               Me2[i]=median(Me[i,])\n             }\n             ratio= Me2/W\n             ratio[Hnnd_root_id]=0\n           },\n           M4 = {\n             # Me=knn_initial$nn.dist\n             # Me = rowMeans(Me)\n             # ratio= Me/W\n             # ratio[Hnnd_root_id]=0\n             ratio = 1/(k_all*Density_initial)\n             ratio[Hnnd_root_id]=0\n           },\n           M5 = { \n             ratio= knn_initial$nn.dist[,K_initial]/W\n             ratio[Hnnd_root_id]=0\n           },\n           mini_k = {\n             ratio= 1/k_all\n             # plot(c(1:length(k_all)),sort(k_all,decreasing = TRUE),log = \"x\",type = \"p\",main = data_name)\n           },\n           K_cut = {\n             ratio = 1/W\n           },\n           critical_k  = {\n             k_all_std = (k_all - mean(k_all))/std(k_all)\n             peaks = which(k_all_std > 2)\n           },\n           critical_ClusN  = { \n             \n             k_all_table=  table(k_all)\n             k_all_cum_backDirection = rep(0,length(k_all_table))\n             for (i in length(k_all_table):1){\n               if (i ==length(k_all_table)){\n                 k_all_cum_backDirection[i] = k_all_table[i]\n               } else {\n                 k_all_cum_backDirection[i] = k_all_table[i]+k_all_cum_backDirection[i+1]\n               }\n             }\n             b = which.min(abs(k_all_cum_backDirection-ClustN))\n             critical_k_threshold = as.numeric(names(k_all_table[b]))\n             \n             peaks = which(k_all>=critical_k_threshold)\n           },\n           critical_ClusN_v2  = { \n             k_diff = k_all - k_all[I_forInTree]\n             k_diff_sorted = sort(k_diff)\n             peaks = which(k_diff > k_diff_sorted[length(k_diff_sorted)-(ClustN-1)])\n             peaks = c(peaks,Hnnd_root_id)\n           },\n           DG_on_critical_Value_only = {\n             k_all[Hnnd_root_id] = 0\n             peaks = DecisionGraph_based_on_critical_value(k_all,I_forInTree,Log = \"n\")\n           },\n           graph_based  = {\n             \n             N = length(I_forInTree)\n             startNodes = c(1:N)[-Hnnd_root_id]\n             endNodes = I_forInTree[-Hnnd_root_id]\n             # EdgeLength = exp(-W_forInTree[-Hnnd_root_id])\n             # EdgeLength = 1/k_all[-Hnnd_root_id]\n             # Me=cbind(knn_initial$nn.dist,knn_initial$nn.dist[I,])\n             # Me = rowMeans(Me)\n             # ratio= Me/W\n             \n             ratio = 1/W\n             \n             EdgeLength = ratio[-Hnnd_root_id]\n             \n             \n             relations = data.frame(\"from\"=startNodes,\"to\"=endNodes,\"weight\"=EdgeLength)\n             \n             # relations=data.frame(\"from\" = rep(1:nrow(result$I_forInTree),times = k), \"to\" = as.vector(knn_initial$nn.index[,-(k+1)]), \"weight\" = as.vector(links))\n             \n             # relations=data.frame(\"from\" = rep(1:nrow(result$I_forInTree),times = k), \"to\" = as.vector(knn_initial$nn.index[,-(k+1)]), \"weight\" = as.vector(links))\n             cat(\"\\n\", \" Build undirected graph from the weighted links...\")\n             t3 <- system.time(g <- graph.data.frame(relations, directed=FALSE))\n             \n             # Other community detection algorithms: \n             #    cluster_walktrap, cluster_spinglass, \n             #    cluster_leading_eigen, cluster_edge_betweenness, \n             #    cluster_fast_greedy, cluster_label_prop, cluster_louvain\n             cat(\"DONE ~\",t3[3],\"s\\n\", \" Run louvain clustering on the graph ...\")\n             t4 <- system.time(community <- cluster_label_prop(g))\n             cat(\"DONE ~\",t4[3],\"s\\n\")\n             Label = as.numeric(membership(community))\n           },\n           M6 = {\n             ratio= 1/W\n             ratio[Hnnd_root_id]=0\n           },\n           TD_based = {\n             thresh_k = 10\n             sample_id = which(k_all>thresh_k)\n             # sample_id = nnd_root_initial\n             # TsTD_samples_only=Tree_symm_Transitive_distance_among_samplings_in_the_in_tree(W,I,sample_id)\n             TsTD_samples_only=Tree_symm_Transitive_distance_among_samplings_in_the_in_tree(W,I,sample_id)\n           },\n           Linkage_on_sampling = {\n             print(\"down-sampling-based clustering\")\n             landmarkidx = which(k_all>thresh_k)\n             \n             hc <- fastcluster::hclust.vector(x[landmarkidx,], Linkage)\n             memb <- cutree(hc, k = min(length(landmarkidx),ClustN))\n             \n             # hdb <- hdbscan(x[landmarkidx,], minPts = ceiling(log2(length(landmarkidx))))\n             # memb = hdb$cluster\n             \n             \n             uni_memb = unique(memb)\n             memb_new = vector()\n             Density_Samp = Density_initial[landmarkidx]\n             for (y in uni_memb){\n               id1 = which(memb == y)\n               Density_Samp_y = Density_Samp[id1]\n               sample_idx_y = landmarkidx[id1]\n               id2 = which.max(Density_Samp_y)\n               memb_new[id1] = sample_idx_y[id2]\n             }\n             \n             # print(memb)\n             # print(memb_new)\n             I[landmarkidx] = memb_new\n           },\n           hdb_based = { \n             source(\"F:/Download_code/TPE/tpe/R/dbscan-master/R/RcppExports.R\")\n             source(\"F:/Download_code/TPE/tpe/R/dbscan-master/R/extractFOSC.R\")\n             id = Hnnd_root_id\n             start_nodes = 1:N\n             Tree=cbind(start_nodes[-id],I[-id],W[-id])\n             hc <- hclustMergeOrder(Tree, order(Tree[, 3]))\n             \n             hdb=extractFOSC(hc,minPts =2)\n             \n           }\n    )\n    \n    # search root nodes (clustering assignments) ------------------------------\n   \n    if (any(intercluster_edges_method_id == c(\"mini_k\",'M5',\"D_ratio_DeltaRho\",\"D_ratio\",\"D_ratio2\",'D_ratio3',\"Ratio_1nnVsG1nn\",\"M2\",\"M4\",\"M6\",\"M3\",\"Ratio_1nnVsG1nn\", \"Ratio_1nnVsG1nn\"))){\n      \n      # remove inter-cluster edges\n      \n      roots_by_cut = Hnnd_root_id\n      M = ClustN\n      for (i in 1:M){\n        idx =which.min(ratio)\n        I[idx]=idx\n        W[idx]=-Inf\n        ratio[idx] = Inf\n        \n        roots_by_cut = c(roots_by_cut,idx)\n      } \n    \n      print(\"search roots:\")\n      \n      # gather at the root nodes\n      I_old=I\n      I=I_old[I_old]\n      while(sum(as.numeric(I-I_old))){\n        I_old=I\n        I=I_old[I_old]\n      }\n       \n      I_after_root_search = I\n      # cluster assignment\n      idx=which(is.infinite(W))\n      Label=vector(length = N)\n      for (i in 1:length(idx)){\n        Label[I==idx[i]]=i\n      }\n      \n      \n    } else if (any(intercluster_edges_method_id == c(\"DG\",\"DG_sampling\",\"boxplot_based\",'critical_k','critical_ClusN','critical_ClusN_v2','DG_on_critical_Value_only'))) {\n      roots_by_cut = peaks\n      I[peaks]=peaks\n      \n      print(\"dynamic update the parent node:\")\n      \n      I_old=I\n      I=I_old[I_old]\n      while(sum(as.numeric(I-I_old))){\n        I_old=I\n        I=I_old[I_old]\n      }\n      \n      I_after_root_search = I\n      \n      # cluster assignment\n      Label = I\n      \n    } else if (intercluster_edges_method_id == \"TD_based\"){\n      # assign the rest samples: method 1\n      \n      # test the results for samples only\n      # hc=fastcluster::hclust(as.dist(TsTD_samples_only),'single')\n      # hdb=extractFOSC(hc,minPts = ceiling(log2(length(nnd_root_initial))))\n      # a=factor(hdb$cluster)\n      \n      # hc=fastcluster::hclust(as.dist(TsTD_samples_only),'average')\n      # a = factor(cutree(hc, k = min(length(sample_id),ClustN)))\n      \n      \n      # Endn = I_forInTree[nnd_root_initial]\n      # sub_I = vector(length = length(nnd_root_initial))\n      # for (ii in 1:length(I_forInTree)){\n      #   sub_I[ii] = which(nnd_root_initial[ii]==Endn)\n      # }\n      # \n      # sub_W = W_forInTree[nnd_root_initial]\n      # id = which(nnd_root_initial == Hnnd_root_id)\n      # start_nodes = (1:length(sub_I))\n      # Tree=cbind(start_nodes[-id],sub_I[-id],sub_W[-id])\n      # \n      \n      \n      hc=fastcluster::hclust(as.dist(TsTD_samples_only),'single')\n      sample_Label = dynamicTreeCut::cutreeDynamic(hc, distM = TsTD_samples_only, method = \"hybrid\", minClusterSize = 2)\n      a = factor(sample_Label)\n      # \n      # # \n      levels_a=as.numeric(levels(a))\n      cnum=length(levels_a)\n      sample_Label=as.numeric(factor(a,levels(a),labels=c(1:cnum)))\n\n      Label = rep(0,length=N)\n      Label[sample_id] = sample_Label\n      noise_id = which(Label==0)\n      non_noise_id = which(Label!=0)\n      if (length(noise_id)!=0){\n        rest_Label=class::knn(x[non_noise_id,], x[noise_id,], factor(sample_Label), k = 3, prob=TRUE)\n        Label[noise_id]=rest_Label\n      }\n      \n      # assign the rest samples: method 2\n    } else if (intercluster_edges_method_id == \"hdb_based\"){\n      print(\"hdb_based\")\n      Label = hdb$cluster\n    } else if (intercluster_edges_method_id == 'graph_based') {\n      Label = as.numeric(membership(community))\n    } else if (intercluster_edges_method_id == \"Linkage_on_sampling\"){\n      print(\"down-sampling-based clustering\")\n      I_old=I\n      I=I_old[I_old]\n      while(sum(as.numeric(I-I_old))){\n        I_old=I\n        I=I_old[I_old]\n      }\n      I_after_root_search = I\n      # cluster assignment\n      Label = I\n      \n    } else{\n      print(\"error\")\n    }\n  }\n    \n if (exists('roots_by_cut')){\n   roots_by_cut = unique(roots_by_cut)\n  \n  if (!is.null(intercluster_edges_method_id)){\n    if (any(InTree_construction_method_id == c(\"NA+++\",\"NA++++\",\"NA+++ (ne.mem.)\"))){\n      return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, Label=Label,k_all = k_all,R_num_each_layer = R_num_each_layer,listRootIndEachLayer= listRootIndEachLayer,Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,roots_by_cut = roots_by_cut,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n    } else { \n      return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, listRootIndEachLayer= listRootIndEachLayer,Label=Label,Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,roots_by_cut = roots_by_cut,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n    }\n  } else {\n    if (any(InTree_construction_method_id == c(\"NA+++\",\"NA++++\",\"NA+++ (ne.mem.)\"))){\n      return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, k_all = k_all,R_num_each_layer = R_num_each_layer,listRootIndEachLayer= listRootIndEachLayer,Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n    } else { \n      return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n    }\n  }\n } else {\n   if (!is.null(intercluster_edges_method_id)){\n     if (any(InTree_construction_method_id == c(\"NA+++\",\"NA++++\",\"NA+++ (ne.mem.)\"))){\n       return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, Label=Label,k_all = k_all,R_num_each_layer = R_num_each_layer,listRootIndEachLayer= listRootIndEachLayer,Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n     } else { \n       return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, listRootIndEachLayer= listRootIndEachLayer,Label=Label,Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n     }\n   } else {\n     if (any(InTree_construction_method_id == c(\"NA+++\",\"NA++++\",\"NA+++ (ne.mem.)\"))){\n       return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, k_all = k_all,R_num_each_layer = R_num_each_layer,listRootIndEachLayer= listRootIndEachLayer,Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n     } else { \n       return(list(I_forInTree = I_forInTree, W_forInTree = W_forInTree, Hnnd_root_id=Hnnd_root_id,Density_initial = Density_initial,knn_initial = knn_initial,Totoltime_DG = Totoltime_DG,I_after_root_search = I_after_root_search))\n     }\n   }\n }\n  \n}\n\n\n\n\n# final ---------------------------------------------------------------\n\n\n\n",
    "created" : 1611146499864.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "369480072",
    "id" : "DA8E48A3",
    "lastKnownWriteTime" : 1596699814,
    "last_content_update" : 1611146542487,
    "path" : "F:/Download_code/TPE/tpe/R/fast_HNND_based_on_unit_free_index_v1_function.R",
    "project_path" : null,
    "properties" : {
        "docOutlineSize" : "198.99431578112473",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}